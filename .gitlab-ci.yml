# Pipeline CI/CD para SMS Spam Detection
# Automatiza testing, building y deployment en DigitalOcean
# Ejecuta autom√°ticamente en cada push al repositorio

# Definici√≥n de stages del pipeline
stages:
  - test          # Ejecuta tests unitarios y validaciones
  - build         # Construye imagen Docker
  - deploy        # Despliega en DigitalOcean Droplet

# Variables globales para todo el pipeline
variables:
  # Configuraci√≥n de Docker
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  
  # Informaci√≥n de la aplicaci√≥n
  APP_NAME: "sms-spam-detector"
  APP_PORT: "8501"
  CONTAINER_NAME: "sms-spam-app"
  
  # Configuraci√≥n de imagen Docker
  DOCKER_IMAGE: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
  DOCKER_IMAGE_LATEST: "$CI_REGISTRY_IMAGE:latest"

# Servicios necesarios para el pipeline
services:
  - docker:20.10.16-dind

# Configuraci√≥n base para jobs que usan Docker
.docker-base: &docker-base
  image: docker:20.10.16
  before_script:
    - docker --version
    - echo "Autenticando con GitLab Container Registry..."
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY

# ===============================================
# STAGE 1: TESTING
# ===============================================

# Job para ejecutar tests unitarios
test-unit:
  stage: test
  image: python:3.10-slim
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - .cache/pip/
      - venv/
  before_script:
    - echo "üß™ Iniciando tests unitarios..."
    - apt-get update -qq && apt-get install -y -qq git
    - python -m venv venv
    - source venv/bin/activate || . venv\\Scripts\\activate
    - python -m pip install --upgrade pip
    - pip install -r configs/requirements.txt
    - pip install pytest pytest-cov pytest-mock
  script:
    - echo "üìã Ejecutando tests de estructura del proyecto..."
    - python -c "
      import sys
      from pathlib import Path
      
      # Verificar estructura de archivos cr√≠ticos
      critical_files = [
          'sms_spam_detector/__init__.py',
          'sms_spam_detector/models/baseline_model.py',
          'sms_spam_detector/utils/data_preprocessing.py',
          'sms_spam_detector/api/app_baseline_only.py',
          'configs/config.yaml',
          'deployment/Dockerfile'
      ]
      
      missing = []
      for file in critical_files:
          if not Path(file).exists():
              missing.append(file)
      
      if missing:
          print('‚ùå Archivos faltantes:', missing)
          sys.exit(1)
      else:
          print('‚úÖ Estructura de proyecto v√°lida')
      "
    - echo "üîç Ejecutando tests de importaci√≥n..."
    - python -c "
      import sys
      sys.path.append('.')
      try:
          from sms_spam_detector.models.baseline_model import BaselineModel
          from sms_spam_detector.utils.data_preprocessing import DataPreprocessor
          print('‚úÖ Imports exitosos')
      except Exception as e:
          print('‚ùå Error en imports:', e)
          sys.exit(1)
      "
    - echo "üìä Ejecutando tests de configuraci√≥n..."
    - python -c "
      import yaml
      from pathlib import Path
      
      config_path = Path('configs/config.yaml')
      if not config_path.exists():
          print('‚ùå Archivo de configuraci√≥n no encontrado')
          exit(1)
      
      with open(config_path) as f:
          config = yaml.safe_load(f)
      
      required_keys = ['data', 'baseline', 'paths', 'app']
      for key in required_keys:
          if key not in config:
              print(f'‚ùå Clave faltante en config: {key}')
              exit(1)
      
      print('‚úÖ Configuraci√≥n v√°lida')
      "
  artifacts:
    expire_in: 1 hour
    paths:
      - venv/
  only:
    - main
    - merge_requests
    - develop

# Job para validar sintaxis de Dockerfiles
test-docker:
  stage: test
  <<: *docker-base
  script:
    - echo "üê≥ Validando Dockerfiles..."
    - |
      for dockerfile in deployment/Dockerfile*; do
        if [ -f "$dockerfile" ]; then
          echo "Validando $dockerfile..."
          docker run --rm -i hadolint/hadolint < "$dockerfile" || echo "Warning: Dockerfile issues found"
        fi
      done
    - echo "‚úÖ Validaci√≥n de Docker completada"
  only:
    - main
    - merge_requests
    - develop

# ===============================================
# STAGE 2: BUILD
# ===============================================

# Job para construir imagen Docker
build-docker:
  stage: build
  <<: *docker-base
  script:
    - echo "üî® Construyendo imagen Docker..."
    - echo "Commit: $CI_COMMIT_SHORT_SHA"
    - echo "Registry: $CI_REGISTRY_IMAGE"
    
    # Construir imagen con multi-stage build
    - |
      docker build \
        --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
        --build-arg VCS_REF=$CI_COMMIT_SHORT_SHA \
        --build-arg VERSION=$CI_COMMIT_REF_NAME \
        -t $DOCKER_IMAGE \
        -t $DOCKER_IMAGE_LATEST \
        -f deployment/Dockerfile.prod .
    
    # Verificar que la imagen se construy√≥ correctamente
    - docker images | grep $CI_REGISTRY_IMAGE
    
    # Push de la imagen al registry
    - echo "üì§ Subiendo imagen al registry..."
    - docker push $DOCKER_IMAGE
    - docker push $DOCKER_IMAGE_LATEST
    
    # Limpiar im√°genes locales para ahorrar espacio
    - docker rmi $DOCKER_IMAGE || true
    - docker rmi $DOCKER_IMAGE_LATEST || true
    
    - echo "‚úÖ Build completado exitosamente"
  only:
    - main
    - develop
  dependencies:
    - test-unit

# ===============================================
# STAGE 3: DEPLOY
# ===============================================

# Job para deployment en producci√≥n (DigitalOcean)
deploy-production:
  stage: deploy
  image: alpine:latest
  before_script:
    - echo "üöÄ Iniciando deployment en producci√≥n..."
    - apk add --no-cache openssh-client bash curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "üì° Conectando al servidor DigitalOcean..."
    - |
      ssh $DEPLOY_USER@$DEPLOY_HOST "
        set -e
        echo 'üõë Parando contenedor anterior si existe...'
        docker stop $CONTAINER_NAME 2>/dev/null || true
        docker rm $CONTAINER_NAME 2>/dev/null || true
        
        echo 'üóëÔ∏è  Limpiando im√°genes no utilizadas...'
        docker image prune -f
        
        echo 'üì• Descargando nueva imagen...'
        echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
        docker pull $DOCKER_IMAGE
        
        echo 'üöÄ Iniciando nueva aplicaci√≥n...'
        docker run -d \
          --name $CONTAINER_NAME \
          --restart unless-stopped \
          -p $APP_PORT:8501 \
          -e ENVIRONMENT=production \
          -e APP_NAME='$APP_NAME' \
          $DOCKER_IMAGE
        
        echo 'üîç Verificando que la aplicaci√≥n est√© corriendo...'
        sleep 10
        if docker ps | grep -q $CONTAINER_NAME; then
          echo '‚úÖ Aplicaci√≥n desplegada exitosamente'
          echo 'üåê Aplicaci√≥n disponible en: http://$DEPLOY_HOST:$APP_PORT'
        else
          echo '‚ùå Error en el despliegue'
          docker logs $CONTAINER_NAME
          exit 1
        fi
        
        echo 'üßπ Limpieza final...'
        docker logout $CI_REGISTRY
      "
    - echo "üéâ Deployment completado!"
    - echo "üåê La aplicaci√≥n est√° disponible en: http://$DEPLOY_HOST:$APP_PORT"
  environment:
    name: production
    url: http://$DEPLOY_HOST:$APP_PORT
  when: manual  # Requiere aprobaci√≥n manual para producci√≥n
  only:
    - main
  dependencies:
    - build-docker

# Job para deployment autom√°tico en desarrollo
deploy-staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - echo "üß™ Iniciando deployment en staging..."
    - apk add --no-cache openssh-client bash curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "üì° Conectando al servidor staging..."
    - |
      ssh $DEPLOY_USER@$STAGING_HOST "
        set -e
        echo 'üõë Parando contenedor de staging anterior...'
        docker stop ${CONTAINER_NAME}-staging 2>/dev/null || true
        docker rm ${CONTAINER_NAME}-staging 2>/dev/null || true
        
        echo 'üì• Descargando imagen de desarrollo...'
        echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
        docker pull $DOCKER_IMAGE
        
        echo 'üöÄ Iniciando aplicaci√≥n en staging...'
        docker run -d \
          --name ${CONTAINER_NAME}-staging \
          --restart unless-stopped \
          -p $((APP_PORT + 1000)):8501 \
          -e ENVIRONMENT=staging \
          -e APP_NAME='$APP_NAME-staging' \
          $DOCKER_IMAGE
        
        sleep 5
        if docker ps | grep -q ${CONTAINER_NAME}-staging; then
          echo '‚úÖ Staging desplegado exitosamente'
        else
          echo '‚ùå Error en staging'
          docker logs ${CONTAINER_NAME}-staging
          exit 1
        fi
      "
  environment:
    name: staging
    url: http://$STAGING_HOST:$((APP_PORT + 1000))
  only:
    - develop
  dependencies:
    - build-docker

# ===============================================
# JOBS ESPECIALES
# ===============================================

# Job para rollback en caso de problemas
rollback:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "üîÑ Ejecutando rollback..."
    - |
      ssh $DEPLOY_USER@$DEPLOY_HOST "
        docker stop $CONTAINER_NAME || true
        docker rm $CONTAINER_NAME || true
        docker run -d \
          --name $CONTAINER_NAME \
          --restart unless-stopped \
          -p $APP_PORT:8501 \
          $DOCKER_IMAGE_LATEST
        echo '‚úÖ Rollback completado'
      "
  when: manual
  only:
    - main

# Job para limpiar registry (ejecutar ocasionalmente)
cleanup:
  stage: deploy
  image: alpine:latest
  script:
    - echo "üßπ Limpieza de im√°genes antiguas..."
    - echo "Este job debe configurarse para limpiar im√°genes del registry"
    - echo "Se ejecutar√° limpieza local en el servidor"
  when: manual
  only:
    - main
